# 规范驱动开发（SDD）

## 权力的颠倒

几十年来，代码一直是王者。规范服务于代码——它们是我们搭建的脚手架，在“真正的工作”开始后就被丢弃。我们编写 PRD 指导开发，创建设计文档以告知实现，绘制架构图。但这些始终是代码的附属品。代码是真理。其他一切，充其量只是美好的意愿。代码是事实的来源，规范很少能跟上它的步伐。

规范驱动开发（SDD）颠倒了这种权力结构。规范不再服务于代码——代码服务于规范。PRD 不再是实现的指导，而是生成实现的源头。技术方案不再是告知编码的文档，而是能生成代码的精确定义。这不是对开发方式的渐进改进，而是对驱动开发本质的彻底重塑。

规范与实现之间的鸿沟困扰着软件开发。我们试图用更好的文档、更详细的需求、更严格的流程来弥合，但这些方法都默认了鸿沟的不可避免。SDD 通过让规范和实现计划可执行，彻底消除这一鸿沟。规范和实现计划生成代码时，只有转化，没有鸿沟。

这一转变得益于 AI 能够理解复杂规范并生成详细实现计划。但如果没有结构，AI 的生成会变得混乱。SDD 通过精确、完整、无歧义的规范和实现计划为 AI 提供结构，使规范成为主要产物，代码只是其在特定语言和框架下的表达。

在新世界里，维护软件意味着演进规范。开发团队的意图通过自然语言（“意图驱动开发”）、设计资产、核心原则等表达。开发的通用语言提升到更高层次，代码只是最后一公里。

调试意味着修正生成错误代码的规范和实现计划。重构意味着为清晰而重组。整个开发流程围绕规范为中心，实施计划和代码是持续生成的输出。更新应用或创建新实现，意味着回到规范和实现计划。这是一个 0 -> 1, (1', ..), 2, 3, N 的过程。

开发团队专注于创造力、实验和批判性思维。

## SDD 工作流实践

工作流始于一个想法——往往模糊不清。通过与 AI 的迭代对话，想法变成完整的 PRD。AI 提问、识别边界情况、帮助定义验收标准。传统开发需要数天的会议和文档，SDD 只需数小时。需求和设计变为持续活动，支持团队流程，规范可分支、合并和版本化。

产品经理更新验收标准时，实现计划自动标记受影响的技术决策。架构师发现更优模式时，PRD 也随之更新。

整个规范过程，研究代理收集关键上下文：库兼容性、性能基准、安全影响、组织约束自动集成。

从 PRD，AI 生成将需求映射到技术决策的实现计划。每个技术选择有理由，每个架构决策可追溯到具体需求。AI 持续分析规范，发现歧义、矛盾和缺口，不是一次性门槛，而是持续完善。

规范和实现计划稳定后即可开始代码生成，但不必“完整”。早期生成可用于探索，测试规范的合理性。领域概念变为数据模型，用户故事变为 API，验收场景变为测试。测试与开发合并，测试场景作为规范的一部分生成实现和测试。

反馈循环延伸到生产。生产指标和事件不仅触发修复，还更新规范。性能瓶颈变为新非功能需求，安全漏洞变为约束，影响未来生成。规范、实现和运营现实的迭代舞蹈，带来更深理解和 SDLC 的持续演进。

## SDD 的必要性

三大趋势让 SDD 不仅可能，而且必要：

1. AI 能力已达门槛，自然语言规范可可靠生成代码。这不是取代开发者，而是通过自动化规范到实现的机械转化，提升效率。
2. 软件复杂度指数级增长。现代系统集成众多服务、框架和依赖，手动保持一致性越来越难。SDD 通过规范驱动生成系统性对齐。
3. 变化加速。需求变化比以往更快，转向成为常态。传统开发将变化视为干扰，SDD 让规范驱动实现，转向变为系统性再生成。

SDD 支持“假设/模拟”实验：如果要为业务需求重构或变更应用，如何实现和实验？

SDD 让需求变化成为常规流程。规范驱动实现，转向变为系统性再生成。修改 PRD，相关实现计划自动更新。修改用户故事，API 端点自动再生成。这不仅是初始开发，更是通过变化保持工程速度。

## 核心原则

**规范为通用语言**：规范成为主要产物，代码只是其在特定语言和框架下的表达。维护软件即演进规范。

**可执行规范**：规范必须精确、完整、无歧义，能生成可用系统，消除意图与实现的鸿沟。

**持续完善**：一致性校验持续进行，AI 持续分析规范，发现歧义、矛盾和缺口。

**研究驱动上下文**：研究代理在规范过程中收集技术选项、性能影响和组织约束。

**双向反馈**：生产现实推动规范演进。指标、事件和运营经验成为规范完善的输入。

**分支探索**：从同一规范生成多种实现方案，探索不同优化目标——性能、可维护性、用户体验、成本。

## 实践方法

目前，SDD 需整合现有工具并保持流程纪律：
- AI 助手用于规范迭代开发
- 研究代理收集技术上下文
- 代码生成工具将规范转为实现
- 版本控制系统适应规范优先流程
- AI 分析规范文档进行一致性校验

关键是将规范视为事实来源，代码是为规范服务的生成物。

## SDD 三大命令

SDD 方法通过三大命令自动化规范→计划→任务流程：

### `/specify` 命令

将简单的功能描述转为完整结构化规范并自动管理仓库：
1. **自动编号**：扫描现有规范，确定下一个功能编号（如 001, 002, 003）
2. **分支创建**：根据描述生成语义分支名并自动创建
3. **模板生成**：复制并定制规范模板
4. **目录结构**：创建 `specs/[branch-name]/` 目录

### `/plan` 命令

规范存在后，生成全面实现计划：
1. **规范分析**：理解需求、用户故事和验收标准
2. **合规性校验**：确保符合项目宪法和架构原则
3. **技术转化**：将业务需求转为技术架构和实现细节
4. **详细文档**：生成数据模型、API 合约和测试场景
5. **快速验证**：生成关键验证场景的指南

### `/tasks` 命令

计划和设计文档后，生成可执行任务清单：
1. **输入**：读取 `plan.md`（必需），如有 `data-model.md`、`contracts/`、`research.md` 也读取
2. **任务推导**：将合约、实体和场景转为具体任务
3. **并行化**：标记独立任务 `[P]` 并分组
4. **输出**：写入 `tasks.md`，供任务代理执行

### 示例：构建聊天功能

三大命令如何变革传统开发流程：

**传统方法：**

1. 编写 PRD（2-3 小时）
2. 创建设计文档（2-3 小时）
3. 手动搭建项目结构（30 分钟）
4. 编写技术规范（3-4 小时）
5. 创建测试计划（2 小时）
总计：约 12 小时文档工作

**SDD 命令方法：**

```bash
/specify 实时聊天系统，支持消息历史和用户在线状态
# 自动：
# - 创建分支 "003-chat-system"
# - 生成 specs/003-chat-system/spec.md
# - 填充结构化需求

/plan WebSocket 实现实时消息，PostgreSQL 存储历史，Redis 管理在线状态

/tasks
# 自动生成：
# - specs/003-chat-system/plan.md
# - specs/003-chat-system/research.md（WebSocket 库对比）
# - specs/003-chat-system/data-model.md（消息和用户模型）
# - specs/003-chat-system/contracts/（WebSocket 事件、REST 端点）
# - specs/003-chat-system/quickstart.md（关键验证场景）
# - specs/003-chat-system/tasks.md（任务清单）
```

15 分钟内，你将获得：
- 完整的功能规范，含用户故事和验收标准
- 详细实现计划，含技术选择和理由
- API 合约和数据模型，准备代码生成
- 自动化和手动测试的完整场景
- 所有文档在分支中版本化

### 结构化自动化的力量

这些命令不仅节省时间，还强制一致性和完整性：
1. **无遗漏细节**：模板确保每个方面都被考虑
2. **决策可追溯**：每个技术选择都可追溯到具体需求
3. **活文档**：规范与代码同步，因为规范生成代码
4. **快速迭代**：需求变更，几分钟内再生成计划

命令体现 SDD 原则，将规范视为可执行产物而非静态文档，规范过程成为开发驱动力。

### 模板约束 LLM，提升规范质量

命令的真正力量在于模板如何约束 LLM，提升规范质量：

#### 1. **防止过早实现细节**

规范模板明确要求：
- ✅ 关注用户需求和原因
- ❌ 避免实现细节（不涉及技术栈、API、代码结构）

这迫使 LLM 保持抽象层级，避免直接跳到“用 React 实现”，而是关注“用户需要实时数据更新”。这样规范即使技术变更也能保持稳定。

#### 2. **强制不确定性标记**

模板要求使用 `[NEEDS CLARIFICATION]` 标记：
1. 标记所有歧义：用 [NEEDS CLARIFICATION: 具体问题]
2. 不猜测：未指定的内容必须标记

防止 LLM 做出可能错误的假设。比如“登录系统”未指定认证方式，必须标记而不是默认邮箱密码。

#### 3. **结构化思考清单**

模板包含完整清单，类似“单元测试”：
- [ ] 无 [NEEDS CLARIFICATION] 标记
- [ ] 需求可测试、无歧义
- [ ] 成功标准可衡量

强制 LLM 系统性自查，补齐遗漏。

#### 4. **宪法合规门槛**

实现计划模板通过阶段门槛强制架构原则：
- 简单性门槛（第七条）：≤3 项目，无超前设计
- 反抽象门槛（第八条）：直接用框架，单一模型

如门槛未通过，LLM 必须在“复杂性跟踪”中记录理由。

#### 5. **分层细节管理**

模板强制信息架构：
- 主要文档保持高层次和可读性
- 代码样例、算法等细节放在 `implementation-details/` 文件

防止规范变成代码堆，保持可导航性。

#### 6. **测试优先思维**

实现模板强制测试优先：
- 先创建合约文件
- 按顺序创建测试文件：合约→集成→端到端→单元
- 创建源文件以通过测试

确保 LLM 先考虑可测试性和合约。

#### 7. **防止推测性功能**

模板明确禁止推测：
- [ ] 无推测或“可能需要”功能
- [ ] 所有阶段有明确前提和交付物

防止 LLM 添加“可选”功能，所有功能都需有具体用户故事和验收标准。

### 复合效应

这些约束共同作用，生成：
- **完整**：清单确保无遗漏
- **无歧义**：强制澄清标记
- **可测试**：测试优先思维
- **可维护**：抽象层级和信息架构
- **可实现**：阶段明确，交付具体

模板将 LLM 从创意写手变为规范工程师，持续生成高质量、可执行规范。

## 宪法基础：强制架构纪律

SDD 的核心是宪法——一套不可变原则，规范如何将规范转为代码。宪法（`memory/constitution.md`）是系统的架构 DNA，确保每次实现都保持一致性、简单性和质量。

### 九大开发条款

宪法定义九条，塑造开发全过程：

#### 第一条：库优先原则

每个功能必须作为独立库开始，无例外。强制模块化设计：
- 每个功能必须作为独立库开始
- 不得直接在应用代码实现，必须先抽象为可复用库组件

确保规范生成模块化、可复用代码。

#### 第二条：CLI 接口强制

每个库必须通过命令行接口暴露功能：
- 所有 CLI 接口必须接受文本输入（stdin、参数或文件）
- 输出文本（stdout）
- 支持 JSON 格式结构化数据交换

强制可观察性和可测试性。

#### 第三条：测试优先原则

最重要的一条——先写测试再写代码：
- 所有实现必须严格遵循测试驱动开发
- 未写单元测试前不得写实现代码
- 测试需用户确认并先失败（红阶段）

彻底颠倒传统 AI 代码生成流程。

#### 第七、八条：简单性与反抽象

这两条防止过度设计：
- 初始实现最多 3 项目，更多需理由
- 直接用框架功能，不做封装

强制 LLM 记录每一层复杂性。

#### 第九条：集成优先测试

优先真实环境测试：
- 优先用真实数据库而非模拟
- 用实际服务实例而非桩
- 实现前必须有合约测试

确保代码在实践中可用。

### 模板强制宪法

实现计划模板通过具体检查点落实宪法：
- 简单性门槛（第七条）：≤3 项目，无超前设计
- 反抽象门槛（第八条）：直接用框架，单一模型
- 集成优先门槛（第九条）：定义合约，先写合约测试

门槛如未通过，必须在“复杂性跟踪”中记录理由。

### 不可变原则的力量

宪法的力量在于不可变性。实现细节可变，核心原则不变，带来：
1. **跨时间一致性**：今天和明年生成的代码遵循同样原则
2. **跨 LLM 一致性**：不同 AI 生成架构兼容代码
3. **架构完整性**：每个功能强化系统设计
4. **质量保证**：测试优先、库优先和简单性原则确保可维护性

### 宪法演进

原则不可变，应用可演进：
- 修改需明确记录理由
- 项目维护者审核
- 评估向后兼容性

这样方法论可学习和完善，同时保持稳定。

### 超越规则：开发哲学

宪法不仅是规则，更是塑造 LLM 代码生成思维的哲学：
- **可观察性优先**：所有功能可通过 CLI 检查
- **简单优先**：先简单，复杂性需证明
- **集成优先**：真实环境测试
- **模块化优先**：每个功能都是边界清晰的库

将这些原则嵌入规范和计划流程，SDD 保证生成代码不仅可用，还可维护、可测试、架构合理。宪法让 AI 成为尊重系统设计的架构伙伴。

## 转变

这不是取代开发者或自动化创造力，而是通过自动化机械转化，提升人类能力。规范、研究和代码的紧密反馈循环，每次迭代带来更深理解和更好意图与实现的对齐。

软件开发需要更好的工具来保持意图与实现的一致性。SDD 通过可执行规范生成代码的方法论，实现这一目标。
